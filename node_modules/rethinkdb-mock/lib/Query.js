// Generated by CoffeeScript 2.3.1
var Query, actions, containsQuery, define, hasQuery, isArray, isArrayOrObject, isFalse, isNullError, isPlainObj, methods, plural, runOnce, seqRE, setProto, slice, statics, utils, variadic;

isPlainObj = require('is-plain-object');

slice = require('lodash.slice');

actions = require('./actions');

utils = require('./utils');

({isArray} = Array);

define = Object.defineProperty;

setProto = Object.setPrototypeOf;

seqRE = /TABLE|SELECTION<ARRAY>/;

Query = function(parent, type) {
  var query;
  query = function(key) {
    return query.bracket(key);
  };
  if (parent) {
    query._db = parent._db;
    query._type = type || parent._type;
    query._parent = parent;
    if (parent._lazy) {
      query._lazy = true;
    }
  } else {
    query._db = null;
    query._type = type || null;
  }
  setProto(query, Query.prototype);
  return query;
};

// Define methods with infinite arity.
variadic = function(keys) {
  return keys.split(' ').forEach(function(key) {
    methods[key] = function() {
      return this._then(key, arguments);
    };
  });
};


// Public methods

methods = {};

methods.default = function(value) {
  return Query._default(this, value);
};

methods.do = function() {
  var args;
  args = slice(arguments);
  return Query._do(this, args);
};

variadic('eq ne gt lt ge le or and add sub mul div');

methods.nth = function(index) {
  return this._then('nth', arguments);
};

methods.bracket = function(key) {
  return this._then('bracket', arguments);
};

methods.getField = function(field) {
  return this._then('getField', arguments);
};

variadic('hasFields');

methods.offsetsOf = function(value) {
  return this._then('offsetsOf', arguments);
};

methods.contains = function(value) {
  return this._then('contains', arguments);
};

methods.orderBy = function(field) {
  return this._then('orderBy', arguments);
};

// TODO: Support mapping over multiple sequences simultaneously.
methods.map = function(query) {
  if (utils.isQuery(query)) {
    if (!query._lazy) {
      throw Error(`Expected \`r.row\` or a FUNCTION, but found ${query._type}`);
    }
  } else if (typeof query === 'function') {
    query = Query._expr(query(Query._row));
  }
  return this._then('map', arguments);
};

methods.filter = function(filter, options) {
  if (typeof filter === 'function') {
    filter = Query._expr(filter(Query._row));
  }
  return this._then('filter', arguments);
};

methods.isEmpty = function() {
  return this._then('isEmpty');
};

methods.count = function() {
  return this._then('count');
};

methods.skip = function(count) {
  return this._then('skip', arguments);
};

methods.limit = function(count) {
  return this._then('limit', arguments);
};

variadic('slice merge pluck without');

methods.typeOf = function() {
  return this._then('typeOf');
};

methods.branch = function() {
  var args;
  args = slice(arguments);
  if (args.length < 2) {
    throw Error(`\`branch\` takes at least 2 arguments, ${args.length} provided`);
  }
  return Query._branch(this, args);
};

methods.update = function(patch) {
  return this._then('update', arguments);
};

methods.replace = function(values) {
  return this._then('replace', arguments);
};

methods.delete = function() {
  return this._then('delete');
};

methods.run = function() {
  return Promise.resolve().then(this._run.bind(this));
};

methods.then = function(onFulfilled) {
  return this.run().then(onFulfilled);
};

methods.catch = function(onRejected) {
  return this.run().catch(onRejected);
};


// Internal

methods._then = function(actionId, args) {
  var query;
  query = Query(this, actions[actionId].type);
  query._actionId = actionId;
  if (args) {
    query._args = args;
    query._parseArgs();
  }
  return query;
};

methods._parseArgs = function() {
  var args;
  args = utils.cloneArray(this._args);
  if (containsQuery(args)) {
    this._args = Query._args(args);
    return;
  }
  utils.assertArity(this._actionId, args);
  this._args = args;
};

methods._eval = function(ctx) {
  var actionId, args, result;
  actionId = this._actionId;
  result = this._parent._eval(ctx);
  args = this._args;
  if (utils.isQuery(args)) {
    args = args._run();
    utils.assertArity(actionId, args);
  }
  if (typeof actionId === 'string') {
    result = actions[actionId].call(ctx, result, args);
  }
  ctx.type = typeof this._type === 'function' ? this._type.call(this, ctx, args) : this._type;
  return result;
};

methods._run = function(ctx = {}) {
  var result;
  ctx.db = this._db;
  result = this._eval(ctx);
  if (/TABLE|SELECTION/.test(ctx.type)) {
    return utils.clone(result);
  }
  return result;
};


// Static methods

statics = {};

// TODO: Evaluate queries from last to first.
statics._do = function(parent, args) {
  var last, length, query;
  if (!args.length) {
    return parent;
  }
  query = Query();
  query._parent = parent;
  last = args.pop();
  args.unshift(parent);
  if (typeof last === 'function') {
    ({length} = last);
    // Allow zero arguments, where none of the given queries are evaluated.
    // Otherwise, enforce the arity of the given function.
    if ((length > 0) && (length !== args.length)) {
      throw Error(`Expected function with ${plural('argument', args.length)} but found function with ${plural('argument', last.length)}`);
    }
    // TODO: Currently, the given function is called more than once.
    //   This is different from `rethinkdbdash`, but easier to implement.
    //   The ideal solution calls the given function once, but also ensures
    //   the given queries are all called once (no more, no less).
    query._eval = function(ctx) {
      var value;
      // Run the given queries once (no more, no less)
      // only if the given function is using them.
      value = length ? last.apply(null, args.map(runOnce)) : last();
      if (value === void 0) {
        throw Error('Anonymous function returned `undefined`. Did you forget a `return`?');
      }
      return utils.resolve(value, ctx);
    };
    return query;
  }
  // TODO: Support `r.row` when no function is given.
  query._eval = function(ctx) {
    var index, value;
    // The given queries are evaluated from last to first.
    value = utils.resolve(last, ctx);
    index = args.length;
    while (--index >= 0) {
      utils.resolve(args[index]);
    }
    return value;
  };
  return query;
};

statics._default = function(parent, value) {
  var query;
  if (!utils.isQuery(value)) {
    value = Query._expr(value);
  }
  query = Query();
  query._parent = parent;
  query._eval = function(ctx) {
    var error, result;
    try {
      result = parent._eval(ctx);
    } catch (error1) {
      error = error1;
      if (!isNullError(error)) {
        throw error;
      }
    }
    return result != null ? result : value._eval(ctx);
  };
  return query;
};

statics._branch = function(cond, args) {
  var lastIndex, query;
  if (args.length % 2) {
    throw Error('`branch` cannot be called with an even number of arguments');
  }
  lastIndex = args.length - 1;
  query = Query();
  query._parent = cond;
  query._eval = function(ctx) {
    var index;
    if (!isFalse(cond._eval({}))) {
      return utils.resolve(args[0], ctx);
    }
    index = -1;
    while ((index += 2) !== lastIndex) {
      if (!isFalse(utils.resolve(args[index]))) {
        return utils.resolve(args[index + 1], ctx);
      }
    }
    return utils.resolve(args[lastIndex], ctx);
  };
  return query;
};

statics._expr = function(expr) {
  var query, values;
  if (expr === void 0) {
    throw Error('Cannot convert `undefined` with r.expr()');
  }
  if ((typeof expr === 'number') && !isFinite(expr)) {
    throw Error(`Cannot convert \`${expr}\` to JSON`);
  }
  if (utils.isQuery(expr)) {
    return expr;
  }
  query = Query(null, 'DATUM');
  if (isArrayOrObject(expr)) {
    values = expr;
    expr = isArray(values) ? [] : {};
    utils.each(values, function(value, key) {
      if (!utils.isQuery(value)) {
        value = Query._expr(value);
      } else if (seqRE.test(value._type)) {
        throw Error(`Expected type DATUM but found ${value._type}`);
      }
      if (value._lazy) {
        query._lazy = true;
      }
      expr[key] = value;
    });
    query._eval = function(ctx) {
      ctx.type = this._type;
      return utils.resolve(expr, ctx);
    };
  } else {
    query._eval = function(ctx) {
      ctx.type = this._type;
      return expr;
    };
  }
  return query;
};

statics._row = (function() {
  var query;
  query = Query(null, 'ROW');
  query._lazy = true;
  query._eval = function(ctx) {
    ctx.type = 'DATUM';
    if (ctx.row) {
      return ctx.row;
    }
    throw Error('r.row is not defined in this context');
  };
  return query;
})();

// TODO: Detect queries nested in `r.expr`
statics._args = function(args) {
  var query;
  args = args.map(Query._expr);
  query = Query(null, 'ARGS');
  query._eval = function(ctx) {
    var values;
    ctx.type = 'DATUM';
    values = [];
    args.forEach(function(arg) {
      if (arg._lazy) {
        values.push(arg);
        return;
      }
      if (arg._type === 'ARGS') {
        values = values.concat(arg._run());
        return;
      }
      values.push(arg._run());
    });
    return values;
  };
  return query;
};


// Exports

utils.each(methods, function(method, key) {
  return define(Query.prototype, key, {
    value: method,
    writable: true
  });
});

utils.each(statics, function(value, key) {
  return define(Query, key, {value});
});

module.exports = Query;


// Helpers

plural = function(noun, count) {
  if (count === 1) {
    return '1 ' + noun;
  }
  return count + ' ' + noun + 's';
};

runOnce = function(arg) {
  if (utils.isQuery(arg)) {
    return Query._expr(arg._run());
  } else {
    return Query._expr(arg);
  }
};

isFalse = function(value) {
  return (value === null) || (value === false);
};

isArrayOrObject = function(value) {
  return isArray(value) || isPlainObj(value);
};

isNullError = function(error) {
  return !error || /(Index out of bounds|No attribute|null)/i.test(error.message);
};

hasQuery = function(object) {
  var key, value;
  for (key in object) {
    value = object[key];
    if (isPlainObj(value)) {
      if (hasQuery(value)) {
        return true;
      }
    } else if (isArray(value)) {
      if (containsQuery(value)) {
        return true;
      }
    } else if (utils.isQuery(value)) {
      return true;
    }
  }
  return false;
};

containsQuery = function(array) {
  var i, len, value;
  for (i = 0, len = array.length; i < len; i++) {
    value = array[i];
    if (isPlainObj(value)) {
      if (hasQuery(value)) {
        return true;
      }
    } else if (isArray(value)) {
      if (containsQuery(value)) {
        return true;
      }
    } else if (utils.isQuery(value)) {
      return true;
    }
  }
  return false;
};
